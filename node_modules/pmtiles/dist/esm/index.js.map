{"version":3,"sources":["../../src/index.ts","../../src/adapters.ts"],"sourcesContent":["import { decompressSync } from \"fflate\";\nexport * from \"./adapters\";\n\n/** @hidden */\nexport interface BufferPosition {\n  buf: Uint8Array;\n  pos: number;\n}\n\nfunction toNum(low: number, high: number): number {\n  return (high >>> 0) * 0x100000000 + (low >>> 0);\n}\n\nfunction readVarintRemainder(l: number, p: BufferPosition): number {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let h = (b & 0x70) >> 4;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 3;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 10;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 17;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 24;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x01) << 31;\n  if (b < 0x80) return toNum(l, h);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\n\n/** @hidden */\nexport function readVarint(p: BufferPosition): number {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let val = b & 0x7f;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 7;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 14;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 21;\n  if (b < 0x80) return val;\n  b = buf[p.pos];\n  val |= (b & 0x0f) << 28;\n\n  return readVarintRemainder(val, p);\n}\n\nfunction rotate(n: number, xy: number[], rx: number, ry: number): void {\n  if (ry === 0) {\n    if (rx === 1) {\n      xy[0] = n - 1 - xy[0];\n      xy[1] = n - 1 - xy[1];\n    }\n    const t = xy[0];\n    xy[0] = xy[1];\n    xy[1] = t;\n  }\n}\n\nfunction idOnLevel(z: number, pos: number): [number, number, number] {\n  const n = 2 ** z;\n  let rx = pos;\n  let ry = pos;\n  let t = pos;\n  const xy = [0, 0];\n  let s = 1;\n  while (s < n) {\n    rx = 1 & (t / 2);\n    ry = 1 & (t ^ rx);\n    rotate(s, xy, rx, ry);\n    xy[0] += s * rx;\n    xy[1] += s * ry;\n    t = t / 4;\n    s *= 2;\n  }\n  return [z, xy[0], xy[1]];\n}\n\nconst tzValues: number[] = [\n  0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405,\n  22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245,\n  91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221,\n  93824992236885, 375299968947541, 1501199875790165,\n];\n\n/**\n * Convert Z,X,Y to a Hilbert TileID.\n */\nexport function zxyToTileId(z: number, x: number, y: number): number {\n  if (z > 26) {\n    throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n  }\n  if (x > 2 ** z - 1 || y > 2 ** z - 1) {\n    throw new Error(\"tile x/y outside zoom level bounds\");\n  }\n\n  const acc = tzValues[z];\n  const n = 2 ** z;\n  let rx = 0;\n  let ry = 0;\n  let d = 0;\n  const xy = [x, y];\n  let s = n / 2;\n  while (s > 0) {\n    rx = (xy[0] & s) > 0 ? 1 : 0;\n    ry = (xy[1] & s) > 0 ? 1 : 0;\n    d += s * s * ((3 * rx) ^ ry);\n    rotate(s, xy, rx, ry);\n    s = s / 2;\n  }\n  return acc + d;\n}\n\n/**\n * Convert a Hilbert TileID to Z,X,Y.\n */\nexport function tileIdToZxy(i: number): [number, number, number] {\n  let acc = 0;\n  const z = 0;\n\n  for (let z = 0; z < 27; z++) {\n    const numTiles = (0x1 << z) * (0x1 << z);\n    if (acc + numTiles > i) {\n      return idOnLevel(z, i - acc);\n    }\n    acc += numTiles;\n  }\n\n  throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n}\n\n/**\n * PMTiles v3 directory entry.\n */\nexport interface Entry {\n  tileId: number;\n  offset: number;\n  length: number;\n  runLength: number;\n}\n\ninterface MetadataLike {\n  attribution?: string;\n  name?: string;\n  version?: string;\n  // biome-ignore lint: TileJSON spec\n  vector_layers?: string;\n  description?: string;\n}\n\n/**\n * Enum representing a compression algorithm used.\n * 0 = unknown compression, for if you must use a different or unspecified algorithm.\n * 1 = no compression.\n */\nexport enum Compression {\n  Unknown = 0,\n  None = 1,\n  Gzip = 2,\n  Brotli = 3,\n  Zstd = 4,\n}\n\n/**\n * Provide a decompression implementation that acts on `buf` and returns decompressed data.\n *\n * Should use the native DecompressionStream on browsers, zlib on node.\n * Should throw if the compression algorithm is not supported.\n */\nexport type DecompressFunc = (\n  buf: ArrayBuffer,\n  compression: Compression\n) => Promise<ArrayBuffer>;\n\nasync function defaultDecompress(\n  buf: ArrayBuffer,\n  compression: Compression\n): Promise<ArrayBuffer> {\n  if (compression === Compression.None || compression === Compression.Unknown) {\n    return buf;\n  }\n  if (compression === Compression.Gzip) {\n    // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n    if (typeof (globalThis as any).DecompressionStream === \"undefined\") {\n      return decompressSync(new Uint8Array(buf));\n    }\n    const stream = new Response(buf).body;\n    if (!stream) {\n      throw new Error(\"Failed to read response stream\");\n    }\n    const result: ReadableStream<Uint8Array> = stream.pipeThrough(\n      // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n      new (globalThis as any).DecompressionStream(\"gzip\")\n    );\n    return new Response(result).arrayBuffer();\n  }\n  throw new Error(\"Compression method not supported\");\n}\n\n/**\n * Describe the type of tiles stored in the archive.\n * 0 is unknown/other, 1 is \"MVT\" vector tiles.\n */\nexport enum TileType {\n  Unknown = 0,\n  Mvt = 1,\n  Png = 2,\n  Jpeg = 3,\n  Webp = 4,\n  Avif = 5,\n}\n\nexport function tileTypeExt(t: TileType): string {\n  if (t === TileType.Mvt) return \".mvt\";\n  if (t === TileType.Png) return \".png\";\n  if (t === TileType.Jpeg) return \".jpg\";\n  if (t === TileType.Webp) return \".webp\";\n  if (t === TileType.Avif) return \".avif\";\n  return \"\";\n}\n\nconst HEADER_SIZE_BYTES = 127;\n\n/**\n * PMTiles v3 header storing basic archive-level information.\n */\nexport interface Header {\n  specVersion: number;\n  rootDirectoryOffset: number;\n  rootDirectoryLength: number;\n  jsonMetadataOffset: number;\n  jsonMetadataLength: number;\n  leafDirectoryOffset: number;\n  leafDirectoryLength?: number;\n  tileDataOffset: number;\n  tileDataLength?: number;\n  numAddressedTiles: number;\n  numTileEntries: number;\n  numTileContents: number;\n  clustered: boolean;\n  internalCompression: Compression;\n  tileCompression: Compression;\n  tileType: TileType;\n  minZoom: number;\n  maxZoom: number;\n  minLon: number;\n  minLat: number;\n  maxLon: number;\n  maxLat: number;\n  centerZoom: number;\n  centerLon: number;\n  centerLat: number;\n  etag?: string;\n}\n\n/**\n * Low-level function for looking up a TileID or leaf directory inside a directory.\n */\nexport function findTile(entries: Entry[], tileId: number): Entry | null {\n  let m = 0;\n  let n = entries.length - 1;\n  while (m <= n) {\n    const k = (n + m) >> 1;\n    const cmp = tileId - entries[k].tileId;\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return entries[k];\n    }\n  }\n\n  // at this point, m > n\n  if (n >= 0) {\n    if (entries[n].runLength === 0) {\n      return entries[n];\n    }\n    if (tileId - entries[n].tileId < entries[n].runLength) {\n      return entries[n];\n    }\n  }\n  return null;\n}\n\nexport interface RangeResponse {\n  data: ArrayBuffer;\n  etag?: string;\n  expires?: string;\n  cacheControl?: string;\n}\n\n/**\n * Interface for retrieving an archive from remote or local storage.\n */\nexport interface Source {\n  getBytes: (\n    offset: number,\n    length: number,\n    signal?: AbortSignal,\n    etag?: string\n  ) => Promise<RangeResponse>;\n\n  /**\n   * Return a unique string key for the archive e.g. a URL.\n   */\n  getKey: () => string;\n}\n\n/**\n * Use the Browser's File API, which is different from the NodeJS file API.\n * see https://developer.mozilla.org/en-US/docs/Web/API/File_API\n */\nexport class FileSource implements Source {\n  file: File;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  getKey() {\n    return this.file.name;\n  }\n\n  async getBytes(offset: number, length: number): Promise<RangeResponse> {\n    const blob = this.file.slice(offset, offset + length);\n    const a = await blob.arrayBuffer();\n    return { data: a };\n  }\n}\n\n/**\n * Uses the browser Fetch API to make tile requests via HTTP.\n *\n * This method does not send conditional request headers If-Match because of CORS.\n * Instead, it detects ETag mismatches via the response ETag or the 416 response code.\n *\n * This also works around browser and storage-specific edge cases.\n */\nexport class FetchSource implements Source {\n  url: string;\n\n  /**\n   * A [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object, specfying custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   *\n   * This should be used instead of maplibre's [transformRequest](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#example) for PMTiles archives.\n   */\n  customHeaders: Headers;\n  /** @hidden */\n  mustReload: boolean;\n  /** @hidden */\n  chromeWindowsNoCache: boolean;\n\n  constructor(url: string, customHeaders: Headers = new Headers()) {\n    this.url = url;\n    this.customHeaders = customHeaders;\n    this.mustReload = false;\n    let userAgent = \"\";\n    if (\"navigator\" in globalThis) {\n      //biome-ignore lint: cf workers\n      userAgent = (globalThis as any).navigator.userAgent || \"\";\n    }\n    const isWindows = userAgent.indexOf(\"Windows\") > -1;\n    const isChromiumBased = /Chrome|Chromium|Edg|OPR|Brave/.test(userAgent);\n    this.chromeWindowsNoCache = false;\n    if (isWindows && isChromiumBased) {\n      this.chromeWindowsNoCache = true;\n    }\n  }\n\n  getKey() {\n    return this.url;\n  }\n\n  /**\n   * Mutate the custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   */\n  setHeaders(customHeaders: Headers) {\n    this.customHeaders = customHeaders;\n  }\n\n  async getBytes(\n    offset: number,\n    length: number,\n    passedSignal?: AbortSignal,\n    etag?: string\n  ): Promise<RangeResponse> {\n    let controller: AbortController | undefined;\n    let signal: AbortSignal | undefined;\n    if (passedSignal) {\n      signal = passedSignal;\n    } else {\n      controller = new AbortController();\n      signal = controller.signal;\n    }\n\n    const requestHeaders = new Headers(this.customHeaders);\n    requestHeaders.set(\"range\", `bytes=${offset}-${offset + length - 1}`);\n\n    // we don't send if match because:\n    // * it disables browser caching completely (Chromium)\n    // * it requires a preflight request for every tile request\n    // * it requires CORS configuration becasue If-Match is not a CORs-safelisted header\n    // CORs configuration should expose ETag.\n    // if any etag mismatch is detected, we need to ignore the browser cache\n    let cache: string | undefined;\n    if (this.mustReload) {\n      cache = \"reload\";\n    } else if (this.chromeWindowsNoCache) {\n      cache = \"no-store\";\n    }\n\n    let resp = await fetch(this.url, {\n      signal: signal,\n      cache: cache,\n      headers: requestHeaders,\n      //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n    } as any);\n\n    // handle edge case where the archive is < 16384 kb total.\n    if (offset === 0 && resp.status === 416) {\n      const contentRange = resp.headers.get(\"Content-Range\");\n      if (!contentRange || !contentRange.startsWith(\"bytes */\")) {\n        throw new Error(\"Missing content-length on 416 response\");\n      }\n      const actualLength = +contentRange.substr(8);\n      resp = await fetch(this.url, {\n        signal: signal,\n        cache: \"reload\",\n        headers: { range: `bytes=0-${actualLength - 1}` },\n        //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n      } as any);\n    }\n\n    // if it's a weak etag, it's not useful for us, so ignore it.\n    let newEtag = resp.headers.get(\"Etag\");\n    if (newEtag?.startsWith(\"W/\")) {\n      newEtag = null;\n    }\n\n    // some storage systems are misbehaved (Cloudflare R2)\n    if (resp.status === 416 || (etag && newEtag && newEtag !== etag)) {\n      this.mustReload = true;\n      throw new EtagMismatch(\n        `Server returned non-matching ETag ${etag} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`\n      );\n    }\n\n    if (resp.status >= 300) {\n      throw new Error(`Bad response code: ${resp.status}`);\n    }\n\n    // some well-behaved backends, e.g. DigitalOcean CDN, respond with 200 instead of 206\n    // but we also need to detect no support for Byte Serving which is returning the whole file\n    const contentLength = resp.headers.get(\"Content-Length\");\n    if (resp.status === 200 && (!contentLength || +contentLength > length)) {\n      if (controller) controller.abort();\n      throw new Error(\n        \"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\"\n      );\n    }\n\n    const a = await resp.arrayBuffer();\n    return {\n      data: a,\n      etag: newEtag || undefined,\n      cacheControl: resp.headers.get(\"Cache-Control\") || undefined,\n      expires: resp.headers.get(\"Expires\") || undefined,\n    };\n  }\n}\n\n/** @hidden */\nexport function getUint64(v: DataView, offset: number): number {\n  const wh = v.getUint32(offset + 4, true);\n  const wl = v.getUint32(offset + 0, true);\n  return wh * 2 ** 32 + wl;\n}\n\n/**\n * Parse raw header bytes into a Header object.\n */\nexport function bytesToHeader(bytes: ArrayBuffer, etag?: string): Header {\n  const v = new DataView(bytes);\n  const specVersion = v.getUint8(7);\n  if (specVersion > 3) {\n    throw new Error(\n      `Archive is spec version ${specVersion} but this library supports up to spec version 3`\n    );\n  }\n\n  return {\n    specVersion: specVersion,\n    rootDirectoryOffset: getUint64(v, 8),\n    rootDirectoryLength: getUint64(v, 16),\n    jsonMetadataOffset: getUint64(v, 24),\n    jsonMetadataLength: getUint64(v, 32),\n    leafDirectoryOffset: getUint64(v, 40),\n    leafDirectoryLength: getUint64(v, 48),\n    tileDataOffset: getUint64(v, 56),\n    tileDataLength: getUint64(v, 64),\n    numAddressedTiles: getUint64(v, 72),\n    numTileEntries: getUint64(v, 80),\n    numTileContents: getUint64(v, 88),\n    clustered: v.getUint8(96) === 1,\n    internalCompression: v.getUint8(97),\n    tileCompression: v.getUint8(98),\n    tileType: v.getUint8(99),\n    minZoom: v.getUint8(100),\n    maxZoom: v.getUint8(101),\n    minLon: v.getInt32(102, true) / 10000000,\n    minLat: v.getInt32(106, true) / 10000000,\n    maxLon: v.getInt32(110, true) / 10000000,\n    maxLat: v.getInt32(114, true) / 10000000,\n    centerZoom: v.getUint8(118),\n    centerLon: v.getInt32(119, true) / 10000000,\n    centerLat: v.getInt32(123, true) / 10000000,\n    etag: etag,\n  };\n}\n\nfunction deserializeIndex(buffer: ArrayBuffer): Entry[] {\n  const p = { buf: new Uint8Array(buffer), pos: 0 };\n  const numEntries = readVarint(p);\n\n  const entries: Entry[] = [];\n\n  let lastId = 0;\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });\n    lastId += v;\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].runLength = readVarint(p);\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].length = readVarint(p);\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    if (v === 0 && i > 0) {\n      entries[i].offset = entries[i - 1].offset + entries[i - 1].length;\n    } else {\n      entries[i].offset = v - 1;\n    }\n  }\n\n  return entries;\n}\n\nfunction detectVersion(a: ArrayBuffer): number {\n  const v = new DataView(a);\n  if (v.getUint16(2, true) === 2) {\n    console.error(\n      \"PMTiles spec version 2 is not supported; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 2;\n  }\n  if (v.getUint16(2, true) === 1) {\n    console.error(\n      \"PMTiles spec version 1 is not supported; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 1;\n  }\n  return 3;\n}\n\n/**\n * Error thrown when a response for PMTiles over HTTP does not match previous, cached parts of the archive.\n * The default PMTiles implementation will catch this error once internally and retry a request.\n */\nexport class EtagMismatch extends Error {}\n\n/**\n * Interface for caches of parts (headers, directories) of a PMTiles archive.\n */\nexport interface Cache {\n  getHeader: (source: Source) => Promise<Header>;\n  getDirectory: (\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ) => Promise<Entry[]>;\n  invalidate: (source: Source) => Promise<void>;\n}\n\nasync function getHeaderAndRoot(\n  source: Source,\n  decompress: DecompressFunc\n): Promise<[Header, [string, number, Entry[] | ArrayBuffer]?]> {\n  const resp = await source.getBytes(0, 16384);\n\n  const v = new DataView(resp.data);\n  if (v.getUint16(0, true) !== 0x4d50) {\n    throw new Error(\"Wrong magic number for PMTiles archive\");\n  }\n\n  const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);\n\n  const header = bytesToHeader(headerData, resp.etag);\n\n  // optimistically set the root directory\n  // TODO check root bounds\n  const rootDirData = resp.data.slice(\n    header.rootDirectoryOffset,\n    header.rootDirectoryOffset + header.rootDirectoryLength\n  );\n  const dirKey = `${source.getKey()}|${header.etag || \"\"}|${\n    header.rootDirectoryOffset\n  }|${header.rootDirectoryLength}`;\n\n  const rootDir = deserializeIndex(\n    await decompress(rootDirData, header.internalCompression)\n  );\n  return [header, [dirKey, rootDir.length, rootDir]];\n}\n\nasync function getDirectory(\n  source: Source,\n  decompress: DecompressFunc,\n  offset: number,\n  length: number,\n  header: Header\n): Promise<Entry[]> {\n  const resp = await source.getBytes(offset, length, undefined, header.etag);\n  const data = await decompress(resp.data, header.internalCompression);\n  const directory = deserializeIndex(data);\n  if (directory.length === 0) {\n    throw new Error(\"Empty directory is invalid\");\n  }\n\n  return directory;\n}\n\ninterface ResolvedValue {\n  lastUsed: number;\n  data: Header | Entry[] | ArrayBuffer;\n}\n\n/**\n * A cache for parts of a PMTiles archive where promises are never shared between requests.\n *\n * Runtimes such as Cloudflare Workers cannot share promises between different requests.\n *\n * Only caches headers and directories, not individual tile contents.\n */\nexport class ResolvedValueCache {\n  cache: Map<string, ResolvedValue>;\n  maxCacheEntries: number;\n  counter: number;\n  decompress: DecompressFunc;\n\n  constructor(\n    maxCacheEntries = 100,\n    prefetch = true, // deprecated\n    decompress: DecompressFunc = defaultDecompress\n  ) {\n    this.cache = new Map<string, ResolvedValue>();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n\n  async getHeader(source: Source): Promise<Header> {\n    const cacheKey = source.getKey();\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = cacheValue.data;\n      return data as Header;\n    }\n\n    const res = await getHeaderAndRoot(source, this.decompress);\n    if (res[1]) {\n      this.cache.set(res[1][0], {\n        lastUsed: this.counter++,\n        data: res[1][2],\n      });\n    }\n\n    this.cache.set(cacheKey, {\n      lastUsed: this.counter++,\n      data: res[0],\n    });\n    this.prune();\n    return res[0];\n  }\n\n  async getDirectory(\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ): Promise<Entry[]> {\n    const cacheKey = `${source.getKey()}|${\n      header.etag || \"\"\n    }|${offset}|${length}`;\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = cacheValue.data;\n      return data as Entry[];\n    }\n\n    const directory = await getDirectory(\n      source,\n      this.decompress,\n      offset,\n      length,\n      header\n    );\n    this.cache.set(cacheKey, {\n      lastUsed: this.counter++,\n      data: directory,\n    });\n    this.prune();\n    return directory;\n  }\n\n  prune() {\n    if (this.cache.size > this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = undefined;\n      this.cache.forEach((cacheValue: ResolvedValue, key: string) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n\n  async invalidate(source: Source) {\n    this.cache.delete(source.getKey());\n  }\n}\n\ninterface SharedPromiseCacheValue {\n  lastUsed: number;\n  data: Promise<Header | Entry[] | ArrayBuffer>;\n}\n\n/**\n * A cache for parts of a PMTiles archive where promises can be shared between requests.\n *\n * Only caches headers and directories, not individual tile contents.\n */\nexport class SharedPromiseCache {\n  cache: Map<string, SharedPromiseCacheValue>;\n  invalidations: Map<string, Promise<void>>;\n  maxCacheEntries: number;\n  counter: number;\n  decompress: DecompressFunc;\n\n  constructor(\n    maxCacheEntries = 100,\n    prefetch = true, // deprecated\n    decompress: DecompressFunc = defaultDecompress\n  ) {\n    this.cache = new Map<string, SharedPromiseCacheValue>();\n    this.invalidations = new Map<string, Promise<void>>();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n\n  async getHeader(source: Source): Promise<Header> {\n    const cacheKey = source.getKey();\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = await cacheValue.data;\n      return data as Header;\n    }\n\n    const p = new Promise<Header>((resolve, reject) => {\n      getHeaderAndRoot(source, this.decompress)\n        .then((res) => {\n          if (res[1]) {\n            this.cache.set(res[1][0], {\n              lastUsed: this.counter++,\n              data: Promise.resolve(res[1][2]),\n            });\n          }\n          resolve(res[0]);\n          this.prune();\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n    return p;\n  }\n\n  async getDirectory(\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ): Promise<Entry[]> {\n    const cacheKey = `${source.getKey()}|${\n      header.etag || \"\"\n    }|${offset}|${length}`;\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = await cacheValue.data;\n      return data as Entry[];\n    }\n\n    const p = new Promise<Entry[]>((resolve, reject) => {\n      getDirectory(source, this.decompress, offset, length, header)\n        .then((directory) => {\n          resolve(directory);\n          this.prune();\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n    return p;\n  }\n\n  prune() {\n    if (this.cache.size >= this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = undefined;\n      this.cache.forEach((cacheValue: SharedPromiseCacheValue, key: string) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n\n  async invalidate(source: Source) {\n    const key = source.getKey();\n    if (this.invalidations.get(key)) {\n      return await this.invalidations.get(key);\n    }\n    this.cache.delete(source.getKey());\n    const p = new Promise<void>((resolve, reject) => {\n      this.getHeader(source)\n        .then((h) => {\n          resolve();\n          this.invalidations.delete(key);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.invalidations.set(key, p);\n  }\n}\n\n/**\n * Main class encapsulating PMTiles decoding logic.\n *\n * if `source` is a string, creates a FetchSource using that string as the URL to a remote PMTiles.\n * if no `cache` is passed, use a SharedPromiseCache.\n * if no `decompress` is passed, default to the browser DecompressionStream API with a fallback to `fflate`.\n */\n// biome-ignore lint: that's just how its capitalized\nexport class PMTiles {\n  source: Source;\n  cache: Cache;\n  decompress: DecompressFunc;\n\n  constructor(\n    source: Source | string,\n    cache?: Cache,\n    decompress?: DecompressFunc\n  ) {\n    if (typeof source === \"string\") {\n      this.source = new FetchSource(source);\n    } else {\n      this.source = source;\n    }\n    if (decompress) {\n      this.decompress = decompress;\n    } else {\n      this.decompress = defaultDecompress;\n    }\n    if (cache) {\n      this.cache = cache;\n    } else {\n      this.cache = new SharedPromiseCache();\n    }\n  }\n\n  /**\n   * Return the header of the archive,\n   * including information such as tile type, min/max zoom, bounds, and summary statistics.\n   */\n  async getHeader() {\n    return await this.cache.getHeader(this.source);\n  }\n\n  /** @hidden */\n  async getZxyAttempt(\n    z: number,\n    x: number,\n    y: number,\n    signal?: AbortSignal\n  ): Promise<RangeResponse | undefined> {\n    const tileId = zxyToTileId(z, x, y);\n    const header = await this.cache.getHeader(this.source);\n\n    if (z < header.minZoom || z > header.maxZoom) {\n      return undefined;\n    }\n\n    let dO = header.rootDirectoryOffset;\n    let dL = header.rootDirectoryLength;\n    for (let depth = 0; depth <= 3; depth++) {\n      const directory = await this.cache.getDirectory(\n        this.source,\n        dO,\n        dL,\n        header\n      );\n      const entry = findTile(directory, tileId);\n      if (entry) {\n        if (entry.runLength > 0) {\n          const resp = await this.source.getBytes(\n            header.tileDataOffset + entry.offset,\n            entry.length,\n            signal,\n            header.etag\n          );\n          return {\n            data: await this.decompress(resp.data, header.tileCompression),\n            cacheControl: resp.cacheControl,\n            expires: resp.expires,\n          };\n        }\n        dO = header.leafDirectoryOffset + entry.offset;\n        dL = entry.length;\n      } else {\n        // TODO: We should in fact return a valid RangeResponse\n        // with empty data, but filled in cache control / expires headers\n        return undefined;\n      }\n    }\n    throw new Error(\"Maximum directory depth exceeded\");\n  }\n\n  /**\n   * Primary method to get a single tile's bytes from an archive.\n   *\n   * Returns undefined if the tile does not exist in the archive.\n   */\n  async getZxy(\n    z: number,\n    x: number,\n    y: number,\n    signal?: AbortSignal\n  ): Promise<RangeResponse | undefined> {\n    try {\n      return await this.getZxyAttempt(z, x, y, signal);\n    } catch (e) {\n      if (e instanceof EtagMismatch) {\n        this.cache.invalidate(this.source);\n        return await this.getZxyAttempt(z, x, y, signal);\n      }\n      throw e;\n    }\n  }\n\n  /** @hidden */\n  async getMetadataAttempt(): Promise<unknown> {\n    const header = await this.cache.getHeader(this.source);\n\n    const resp = await this.source.getBytes(\n      header.jsonMetadataOffset,\n      header.jsonMetadataLength,\n      undefined,\n      header.etag\n    );\n    const decompressed = await this.decompress(\n      resp.data,\n      header.internalCompression\n    );\n    const dec = new TextDecoder(\"utf-8\");\n    return JSON.parse(dec.decode(decompressed));\n  }\n\n  /**\n   * Return the arbitrary JSON metadata of the archive.\n   */\n  async getMetadata(): Promise<unknown> {\n    try {\n      return await this.getMetadataAttempt();\n    } catch (e) {\n      if (e instanceof EtagMismatch) {\n        this.cache.invalidate(this.source);\n        return await this.getMetadataAttempt();\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Construct a [TileJSON](https://github.com/mapbox/tilejson-spec) object.\n   *\n   * baseTilesUrl is the desired tiles URL, excluding the suffix `/{z}/{x}/{y}.{ext}`.\n   * For example, if the desired URL is `http://example.com/tileset/{z}/{x}/{y}.mvt`,\n   * the baseTilesUrl should be `https://example.com/tileset`.\n   */\n  async getTileJson(baseTilesUrl: string): Promise<unknown> {\n    const header = await this.getHeader();\n    const metadata = (await this.getMetadata()) as MetadataLike;\n    const ext = tileTypeExt(header.tileType);\n\n    return {\n      tilejson: \"3.0.0\",\n      scheme: \"xyz\",\n      tiles: [`${baseTilesUrl}/{z}/{x}/{y}${ext}`],\n      // biome-ignore lint: TileJSON spec\n      vector_layers: metadata.vector_layers,\n      attribution: metadata.attribution,\n      description: metadata.description,\n      name: metadata.name,\n      version: metadata.version,\n      bounds: [header.minLon, header.minLat, header.maxLon, header.maxLat],\n      center: [header.centerLon, header.centerLat, header.centerZoom],\n      minzoom: header.minZoom,\n      maxzoom: header.maxZoom,\n    };\n  }\n}\n","// biome-ignore lint: needed for Leaflet + IIFE to work\ndeclare const L: any;\n// biome-ignore lint: needed for window.URL to disambiguate from cloudflare workers\ndeclare const window: any;\ndeclare const document: DocumentLike;\n\nimport type { Coords } from \"leaflet\";\nimport { PMTiles, TileType } from \"./index\";\n\ninterface DocumentLike {\n  // biome-ignore lint: we don't want to bring in the entire document type\n  createElement: (s: string) => any;\n}\n\n// biome-ignore lint: we don't want to bring in the entire document type\ntype DoneCallback = (error?: Error, tile?: any) => void;\n\n/**\n * Add a raster PMTiles as a layer to a Leaflet map.\n *\n * For vector tiles see https://github.com/protomaps/protomaps-leaflet\n */\nexport const leafletRasterLayer = (source: PMTiles, options: unknown) => {\n  let loaded = false;\n  let mimeType = \"\";\n  const cls = L.GridLayer.extend({\n    createTile: (coord: Coords, done: DoneCallback) => {\n      const el = document.createElement(\"img\");\n      const controller = new AbortController();\n      const signal = controller.signal;\n      el.cancel = () => {\n        controller.abort();\n      };\n      if (!loaded) {\n        source.getHeader().then((header) => {\n          if (header.tileType === TileType.Mvt) {\n            console.error(\n              \"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"\n            );\n          } else if (header.tileType === 2) {\n            mimeType = \"image/png\";\n          } else if (header.tileType === 3) {\n            mimeType = \"image/jpeg\";\n          } else if (header.tileType === 4) {\n            mimeType = \"image/webp\";\n          } else if (header.tileType === 5) {\n            mimeType = \"image/avif\";\n          }\n        });\n        loaded = true;\n      }\n      source\n        .getZxy(coord.z, coord.x, coord.y, signal)\n        .then((arr) => {\n          if (arr) {\n            const blob = new Blob([arr.data], { type: mimeType });\n            const imageUrl = window.URL.createObjectURL(blob);\n            el.src = imageUrl;\n            el.cancel = undefined;\n            done(undefined, el);\n          }\n        })\n        .catch((e) => {\n          if (e.name !== \"AbortError\") {\n            throw e;\n          }\n        });\n      return el;\n    },\n\n    _removeTile: function (key: string) {\n      const tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n\n      if (tile.el.cancel) tile.el.cancel();\n\n      tile.el.width = 0;\n      tile.el.height = 0;\n      tile.el.deleted = true;\n      L.DomUtil.remove(tile.el);\n      delete this._tiles[key];\n      this.fire(\"tileunload\", {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key),\n      });\n    },\n  });\n  return new cls(options);\n};\n\ntype GetResourceResponse<T> = ExpiryData & {\n  data: T;\n};\ntype AddProtocolAction = (\n  requestParameters: RequestParameters,\n  abortController: AbortController\n) => Promise<GetResourceResponse<unknown>>;\n\ntype ExpiryData = {\n  cacheControl?: string | null;\n  expires?: string | null; // MapLibre can be a Date object\n};\n\n// copied from MapLibre /util/ajax.ts\ntype RequestParameters = {\n  url: string;\n  headers?: unknown;\n  method?: \"GET\" | \"POST\" | \"PUT\";\n  body?: string;\n  type?: \"string\" | \"json\" | \"arrayBuffer\" | \"image\";\n  credentials?: \"same-origin\" | \"include\";\n  collectResourceTiming?: boolean;\n};\n\n// for legacy maplibre-3 interop\ntype ResponseCallbackV3 = (\n  error?: Error | undefined,\n  data?: unknown | undefined,\n  cacheControl?: string | undefined,\n  expires?: string | undefined\n) => void;\n\ntype V3OrV4Protocol = <\n  T extends AbortController | ResponseCallbackV3,\n  R = T extends AbortController\n    ? Promise<GetResourceResponse<unknown>>\n    : { cancel: () => void },\n>(\n  requestParameters: RequestParameters,\n  arg2: T\n) => R;\n\nconst v3compat =\n  (v4: AddProtocolAction): V3OrV4Protocol =>\n  (requestParameters, arg2) => {\n    if (arg2 instanceof AbortController) {\n      // biome-ignore lint: overloading return type not handled by compiler\n      return v4(requestParameters, arg2) as any;\n    }\n    const abortController = new AbortController();\n    v4(requestParameters, abortController)\n      .then(\n        (result) => {\n          return arg2(\n            undefined,\n            result.data,\n            result.cacheControl || \"\",\n            result.expires || \"\"\n          );\n        },\n        (err) => {\n          return arg2(err);\n        }\n      )\n      .catch((e) => {\n        return arg2(e);\n      });\n    return { cancel: () => abortController.abort() };\n  };\n\n/**\n * MapLibre GL JS protocol. Must be added once globally.\n */\nexport class Protocol {\n  /** @hidden */\n  tiles: Map<string, PMTiles>;\n  metadata: boolean;\n  errorOnMissingTile: boolean;\n\n  /**\n   * Initialize the MapLibre PMTiles protocol.\n   *\n   * * metadata: also load the metadata section of the PMTiles. required for some \"inspect\" functionality\n   * and to automatically populate the map attribution. Requires an extra HTTP request.\n   * * errorOnMissingTile: When a vector MVT tile is missing from the archive, raise an error instead of\n   * returning the empty array. Not recommended. This is only to reproduce the behavior of ZXY tile APIs\n   * which some applications depend on when overzooming.\n   */\n  constructor(options?: { metadata?: boolean; errorOnMissingTile?: boolean }) {\n    this.tiles = new Map<string, PMTiles>();\n    this.metadata = options?.metadata || false;\n    this.errorOnMissingTile = options?.errorOnMissingTile || false;\n  }\n\n  /**\n   * Add a {@link PMTiles} instance to the global protocol instance.\n   *\n   * For remote fetch sources, references in MapLibre styles like pmtiles://http://...\n   * will resolve to the same instance if the URLs match.\n   */\n  add(p: PMTiles) {\n    this.tiles.set(p.source.getKey(), p);\n  }\n\n  /**\n   * Fetch a {@link PMTiles} instance by URL, for remote PMTiles instances.\n   */\n  get(url: string) {\n    return this.tiles.get(url);\n  }\n\n  /** @hidden */\n  tilev4 = async (\n    params: RequestParameters,\n    abortController: AbortController\n  ) => {\n    if (params.type === \"json\") {\n      const pmtilesUrl = params.url.substr(10);\n      let instance = this.tiles.get(pmtilesUrl);\n      if (!instance) {\n        instance = new PMTiles(pmtilesUrl);\n        this.tiles.set(pmtilesUrl, instance);\n      }\n\n      if (this.metadata) {\n        return {\n          data: await instance.getTileJson(params.url),\n        };\n      }\n\n      const h = await instance.getHeader();\n\n      if (h.minLon >= h.maxLon || h.minLat >= h.maxLat) {\n        console.error(\n          `Bounds of PMTiles archive ${h.minLon},${h.minLat},${h.maxLon},${h.maxLat} are not valid.`\n        );\n      }\n\n      return {\n        data: {\n          tiles: [`${params.url}/{z}/{x}/{y}`],\n          minzoom: h.minZoom,\n          maxzoom: h.maxZoom,\n          bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat],\n        },\n      };\n    }\n    const re = new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n    const result = params.url.match(re);\n    if (!result) {\n      throw new Error(\"Invalid PMTiles protocol URL\");\n    }\n    const pmtilesUrl = result[1];\n\n    let instance = this.tiles.get(pmtilesUrl);\n    if (!instance) {\n      instance = new PMTiles(pmtilesUrl);\n      this.tiles.set(pmtilesUrl, instance);\n    }\n    const z = result[2];\n    const x = result[3];\n    const y = result[4];\n\n    const header = await instance.getHeader();\n    const resp = await instance?.getZxy(+z, +x, +y, abortController.signal);\n    if (resp) {\n      return {\n        data: new Uint8Array(resp.data),\n        cacheControl: resp.cacheControl,\n        expires: resp.expires,\n      };\n    }\n    if (header.tileType === TileType.Mvt) {\n      if (this.errorOnMissingTile) {\n        throw new Error(\"Tile not found.\");\n      }\n      return { data: new Uint8Array() };\n    }\n    return { data: null };\n  };\n\n  tile = v3compat(this.tilev4);\n}\n"],"mappings":"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","names":["decompressSync","leafletRasterLayer","__name","source","options","loaded","mimeType","cls","coord","done","el","controller","signal","header","arr","blob","imageUrl","e","key","tile","v3compat","v4","requestParameters","arg2","abortController","result","err","_Protocol","params","__async","pmtilesUrl","instance","PMTiles","h","re","z","x","y","resp","p","url","Protocol","toNum","low","high","__name","readVarintRemainder","l","p","buf","b","h","readVarint","val","rotate","n","xy","rx","ry","t","idOnLevel","z","pos","__pow","s","tzValues","zxyToTileId","x","y","acc","d","tileIdToZxy","numTiles","Compression","defaultDecompress","compression","__async","decompressSync","stream","result","TileType","tileTypeExt","HEADER_SIZE_BYTES","findTile","entries","tileId","m","k","cmp","_FileSource","file","offset","length","FileSource","_FetchSource","url","customHeaders","userAgent","isWindows","isChromiumBased","passedSignal","etag","controller","signal","requestHeaders","cache","resp","contentRange","actualLength","newEtag","EtagMismatch","contentLength","FetchSource","getUint64","v","wh","wl","bytesToHeader","bytes","specVersion","deserializeIndex","buffer","numEntries","lastId","i","_EtagMismatch","__name","EtagMismatch","getHeaderAndRoot","source","decompress","__async","resp","headerData","HEADER_SIZE_BYTES","header","bytesToHeader","rootDirData","dirKey","rootDir","deserializeIndex","getDirectory","offset","length","data","directory","_ResolvedValueCache","maxCacheEntries","prefetch","defaultDecompress","cacheKey","cacheValue","res","minUsed","minKey","key","ResolvedValueCache","_SharedPromiseCache","p","resolve","reject","e","h","SharedPromiseCache","_PMTiles","cache","FetchSource","z","x","y","signal","tileId","zxyToTileId","dO","dL","depth","entry","findTile","decompressed","dec","baseTilesUrl","metadata","ext","tileTypeExt","PMTiles"]}